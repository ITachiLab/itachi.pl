= Parsing NEC protocol on STM32 elegantly
Itachi
:xrefstyle: short
:description: Describing a process of parsing NEC infrared protocol on STM32 microcontroller

NEC is one of infrared protocols used for controlling devices such as TVs or amplifiers. The protocol is very simple, it is easy to decode it on microcontroller even with a naive bit banging method. The goal of this article is to describe a more elegant way of doing this by using timers and input capture function of STM32 microcontroller.

== NEC protocol

Let's first take a look at the protocol itself. Since a very good description of this protocol and other IR protocols can be found on https://www.sbprojects.net/knowledge/ir/nec.php[SB-Projects website], I'm not going to dive into details. The most important stuff to know before doing anything can be shortened to a couple of bullet points:

- A single transmission consists of a preamble, device address, negated device address, command and a negated command (in that order). The exception is a command repetition which consists only of a slightly modified preamble.
- Preamble and data bits are always encoded by a high state pulse and a following low state pulse lasting a specific amount of time (shown in the table below).
- The transmission always ends with a short high pulse, some sort of stop bit.
- A window of the transmission starts with the preamble and spans 110 ms. No other transmissions can happen within that window.

.Length of pulses for each transmission part
|===
| |High pulse length |Low pulse length

|Preamble
|9000 μs
|4500 μs

|Bit 0
|560 μs
|560 μs

|Bit 1
|560 μs
|1690 μs

|Stop bit
|560 μs
|∞ μs

|Repeat last command
|9000 μs
|2250 μs
|===

To actually see this protocol in action, I attached a popular IR receiver https://www.vishay.com/docs/82459/tsop48.pdf[TSOP4836] to my logic analyzer and played with a TV remote. Here's what I got:

.Data packet captured by logic analyzer
image::packet.png[xref=image$packet.png]

[[repeat_packet]]
.Repeat packet captured by logic analyzer
image::repeat.png[xref=image$repeat.png]

The center part of the window shows a waveform which is a negated output of TSOP4836. This IR receiver outputs reversed signals by default, so I negated the channel for easier reading. Thankfully the software has a proper protocol decoder, so it displays contents of the transmission right above the waveform. There is no separation for address and negated address, they are simply merged to a single value, but that's fine.

The bottom part of the window shows captured packets in a beautiful way. As you can tell by different data values, I have clicked four different buttons. The burst of short packets at the end signalizes that I have kept the fourth button down for a while, these are repeat packets which you can also observe on <<repeat_packet>>.

== Toys and tools

For this article I'm going to use my immortal _NUCLEO-F103RB_ board. Device configuration and project generation will be done in CubeMX. I'm not a big fan of HAL but this is the _recommended_ way of working with STM32 microcontrollers, especially when more advanced stuff come in to play. Besides, I already know how to write a full code using only registers, it's time to learn HAL eventually.

To receive IR I'm going to use TSOP4836. It's important to keep in mind that this receiver outputs inverted signals, i.e. 0 is high and 1 is low. As long as STM32 is configured properly, this doesn't matter.

== Decoder implementation

We already know that NEC protocol encodes data by simply varying length of pulses. The decoder could be just a simple line polling mechanism that counts how long a pulse lasts, but that's a naive implementation. A much better solution is having a counter that measures these pulses for us in background, so we can analyze the results later in the loop.

=== Device configuration and project setup

Okay, it's time to launch CubeMX and configure the device accordingly to our needs.

==== Timer

.Configuration of a timer
image::timer-configuration.png[xref=image$timer-configuration.png]

[[input_capture_timing]]
.Timing diagram of input capture for PWM input mode
image::input-capture.png[xref=image$input-capture.png]

For measuring pulses I'll be using TIM2. The clock source must be set to *Internal Clock* and two channels must be combined by choosing *PWM Input on CH1*. You will observe that _Channel1_ and _Channel2_ are now unavailable, and _PA0_ has been designated to be PWM input. _PA0_ is also the pin to which I attached _OUT_ pin of my TSOP, so anytime a PWM phase comes out of TSOP, it is caught by input capture unit at two points as presented on <<input_capture_timing>>. The value of input capture for channel 1 contains duration of the full phase, whereas for channel 2 it contains duration of the first (high) part. Duration of the low part is obviously: `TIM2_CCR1 - TIM2_CCR2`.

I also set the prescaler to *64* so the frequency of the timer's clock is 1 MHz. Thanks to this, the timer's counter increments every 1 μs allowing for very easy conversion of counter value to time. The polarity selection must be reversed to comply with TSOP specification (high state when 0, low state when 1).


==== Interrupts

.Configuration of interrupts
image::interrupts-configuration.png[xref=image$interrupts-configuration.png]

*TIM2 global interrupt* must be enabled so we can react to input capture events. This is the only thing to configure here.

==== Callbacks and framework

.Configuration of callbacks and framework
image::callbacks-configuration.png[xref=image$callbacks-configuration.png]

The last step is to enable HAL callbacks for TIM peripheral. This can be done in the _Project Manager_ tab, under _Advanced Settings_. I also chose Low-Level drivers for GPIO instead of HAL. This is because GPIO is pretty simple peripheral and HAL adds too much overhead to it. You are free to use HAL for GPIO if you want.

The project is ready to be generated, do it the way you like it.

==== Input capture setup

CubeMX did most of the configuration for us, but there's one thing that must be configured manually in the code -- input capture. Head over to the generated project and locate a function in which the timer is being initialized; in my case this is: `MX_TIM2_Init`. At the very end of the function body, inside the user code part, add these three lines:

[,c]
----
HAL_TIM_RegisterCallback(&htim2, HAL_TIM_IC_CAPTURE_CB_ID, input_capture_callback);
HAL_TIM_IC_Start_IT(&htim2, TIM_CHANNEL_1);
HAL_TIM_IC_Start(&htim2, TIM_CHANNEL_2);
----

In the first line, a callback function (we don't have it yet) for input capture events is being registered. That means each time there is an input capture event, the `input_capture_callback` function is going to be executed.

In the second line, input capture on channel 1 is enabled in interrupt mode. This means that each time a whole PWM pulse passes through the timer input, an input capture interrupt is generated.

In the third line, input capture on channel 2 is enabled in normal mode. Exactly, no interrupts here. As can be seen on <<input_capture_timing>>, input capture on the second channel is triggered after the first part of the PWM pulse, but this information alone is useless, we need to know the whole pulse length, that's why we have to wait for the whole pulse, which is signalised by input capture on channel 1. Triggering additional interrupt here will be redundant.

== Implementation



Now the fun part begins. There is no one perfect way of implementing NEC decoder, it can be done in hundreds of different ways and each can be equally good. I decided to accomplish this using a _state machine_ approach, simply because I liked this idea.

=== State machine architecture

.State machine diagram
image::state-machine.png[]

When parsing a NEC frame, there is very limited number of directions the parser can go:

- when the parser reads valid and expected data, it processes the data and either stays in the same state or advances to the next;
- when the parser reads header, the parsing process must start from beginning, always;
- when it reads a complete frame, then it stays in a state in which it can react to repetition commands.

The mysterious letters over arrows are events and conditions:

|===
|Label |Type |Description

|D
|Event
|Data bit received

|H
|Event
|Header received

|R
|Event
|Repetition received

|c < 7
|Condition
|Bit counter is less than 7

|c >= 7
|Condition
|Bit counter is greater than or equal to 7
|===

The general workflow of the machine is:

1. Read input capture times.
2. Convert read values to an event.
3. Invoke action appropriate to the current state and the received event.
4. Transition to other state or stay in the present.

For most of the time, the machine transitions to the next state when the number of bits read in the current state is greater than or equal to 7. The transition always happens soon after reading and invoking an *action* on the last bit of the state that is to be left. The actions that can be invoked are:

|===
|Action |When |Consequence

|Reset
|`H`
|Bit counter and data buffer set to zero

|Store data
|`D && c < 7`
|Data bit shifted into the currently processed portion of the frame

|Store data and reset
|`D && c >= 7`
|Data bit shifted into the currently processed portion of the frame and _Reset_ action invoked

|Finish
|`D && c >= 7`, only in _~Command_ state
|Data bit shifted into the currently processed portion of the frame, _Reset_ and _Send NEC_ actions invoked

|Send NEC
|`R`, only in _Finish_ state
|Transmit frame through UART
|===

