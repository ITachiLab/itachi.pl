= Brainfuck assembler
Itachi
:description: An article describing a handcrafted assembler for Brainfuck language.

I believe some of you already heard about *Brainfuck* programming language. This language serves two main purposes:

- it's indeed a programming language,
 - fucks your brain.

Consider this "Hello World" example:

----
++++++++[>++++[>++>+++>+++>+<<<<-]>+>+>->>+[<]<-]>>.>---.+++++++..+++.>>.<-.<.+++.------.--------.>>+.>++.
----

Looks ugly and, what's worse, it works somehow. You can try this snippet in an https://www.nayuki.io/page/brainfuck-interpreter-javascript[online interpreter], which you also should keep open in a new tab as it will be useful during our journey.

Brainfuck is based on a bunch of primitive machine commands, that are apparently sufficient to make Brainfuck a Turing complete language. In other words: you can go and write fully fledged programs in it, but it won't be very convenient.

For obvious reasons (DRY, laziness, me being me) I'm not going to describe how Brainfuck actually works, everything is nicely explained on https://en.wikipedia.org/wiki/Brainfuck[Wikipedia]. The goal of this article is different, we will make writing in Brainfuck slightly more pleasant. Why? For fun of course!

== Hands on

As you might conclude from the article's title, we are going to create an assembler for Brainfuck (suggesting that writing in assembler is more pleasant). At the first sight it might be confusing -- assembler, for a programming language? How about... assembler for a pretty fucked up machine code!

If we treat Brainfuck as a machine code, then Brainfuck's interpreter can be considered a platform providing us with memory and very limited CPU that understands Brainfuck's Machine Code. On this memory we can construct stack and simulate a single CPU register (only one, keeping more of them will be burdensome).

It looks like we aren't creating the assembler solely, but a primitive 8-bit architecture. Sounds like fun!

== Brainfuck Primitive Architecture (BPA)

The assumptions of BPA are as follows:

Memory:: Starts at 0x0 and is limited only by interpreter's implementation.
Stack:: Top of the stack is initially set to -1, meaning that you can't read from the stack if there's nothin on it. Every push operation first increases the stack pointer (SP) and then writes the data. SP is always equal to the *current interpreter's data pointer - 1.*
Register "r0":: This is the only register. It always lives under the current interpreter's data pointer, meaning that it is a part of the memory. Due to this, care must be taken when pushing new thins onto the stack as they can possibly overwrite precious data in r0.
Forced flow of operations:: BPA's CPU instruction pointer can't be modified manually.

Probably the most painful part will be maintaining the stack and the r0 register. Although the concept of the stack is entirely virtual and optional, having it in our toolbox will make writing codes in BPA ASM way easier than without it.

== BPA Assembler

Before we start describing the instruction set, let's define a bunch of simple keywords used in the following section.

`r0`:: The only register we have.
`<con>`:: Any 8-bit constant value.
`[esp - n]`:: Variable on a stack. If `n` is zero (can be omitted), it points to the top of the stack.

=== Simple arithmetic

Simple arithmetical operations like addition or subtraction can be effortlessly constructed using the Brainfuck's increment and decrement commands.

|===
|Instruction|Machine Code|Description

|`inc r0`|`+`|Increase value of r0 register.

|`dec r0`|`-`|Decrease value of r0 register.

|`add r0, <con>`|`+` repeated *con* times.|Increase value of r0 register by a constant value.

|`sub r0, <con>`|`-` repeated *con* times.|Decrease value of r0 register by a constant value.

|`inc [esp - n]`|`<` repeated *n + 1* times, then `+`, then `>` repeated *n + 1* times.|Increase value of a variable on the stack.

|`dec [esp - n]`|`<` repeated *n + 1* times, then `-`, then `>` repeated *n + 1* times.|Decrease value of a variable on the stack.

|`add [esp - n], <con>`|`<` repeated *n + 1* times, then `+` repeated *con* times, then `>` repeated *n + 1* times.|Increase value of a variable on the stack by a constant value.

|`sub [esp - n], <con>`|`<` repeated *n + 1* times, then `-` repeated *con* times, then `>` repeated *n + 1* times.|Decrease value of a variable on the stack by a constant value.

|`zero r0`|`[-]`|Zeroes the *r0* register.

|`zero [esp - n]`|`<` repeated *n* times, then `[-]`, then `>` repeated *n + 1* times.|Zeroes a variable on the stack.
|===

=== Stack operations

This section requires a little more in-depth look than the simple arithmetics. When memory operations are involved, we are responsible for maintaining its consistency.

|===
|Instruction|Machine Code|Description

|`pop`|`<`|xref:_popping_from_the_stack[]

|`push r0`|`+>[-]>[-]<<[->+>+<<]>>[-<<+>>]<+` or sometimes: `>`|xref:_pushing_r0_onto_the_stack[]

|`push <con>`|`+>[-]<[->+<]+`, then repeat `+` *con* times, then `>`; or sometimes: `[-]`, then repeat `+` *con* times, then `>`.|xref:_pushing_constant_onto_the_stack[]
|===

[#_popping_from_the_stack]
==== Popping from the stack

This is the shortest operation that does much.Its purpose is to get the value from the top of the stack and move it to the r0 register. Since the r0 register lives in the memory and is exactly one memory cell right to the top of the stack, the data pointer can be simply decreased, so the r0 register contains the previous stack's top.

[#_pushing_r0_onto_the_stack]
==== Pushing r0 onto the stack

And here it is -- the first more complex instruction. Its purpose is to put the register r0 onto the stack, while keeping the value in the register. Sounds simple, but involves lots of copying and copying isn't simple in Brainfuck. Let's divide and conquer this task.

The first thing we have to take care of is to move r0 to the next memory cell, because the current will become a new stack's top. In Brainfuck we can't just copy values between cells, but we can smartly loop decrease and increase operations. Copying is just using the current cell value as a loop condition, and increasing another cell by one on each loop iteration. Copying the current cell to the next will look like this:

 [->+<]

This tells Brainfuck to enter the loop if the current cell's value is not zero, then decrease the current cell's value, go to the next cell, increase its value, go to the source cell and go back to the loop's start. This will work, but has two caveats:

- it won't copy, it will move the source value, because the source value is used as a loop counter;
- the target cell must be zero.

To tackle the first problem, we have to introduce a temporary memory cell which will be increased along with the target cell. After we move the value from source to target, the temporary cell will be used to restore the source cell's value. This also means that only the target cell must be zero, but the temporary cell too.

....
>           ; Go to the target cell.
[-]         ; Zero it.
>           ; Go to the temporary cell.
[-]         ; Zero it.
<<          ; Go back to the source cell.
[->+>+<<]   ; Until zero, decrease the source cell's value, go to the target cell, increase it, go to the temporary cell, increase it, and go back to the source cell.
>>          ; Go to the temporary cell.
[-<<+>>]    ; Until zero, decrease the temporary cell's value, go to the source cell, increase it, go to the temporary cell.
....

When the above sequence finishes, the source and the target cell will have the same value. To complete the whole operation for our purposes, the data pointer must be decreased to point at the new r0 position, thus the final form will be:

 >[-]>[-]<<[->+>+<<]>>[-<<+>>]<

===== Possible optimization

In some circumstances, the push operation can be significantly optimized. Consider the following pair of instructions:

 push   r0
 mov    r0, 15

(We didn't talk about `mov` yet, but we will.)

First, the r0 is pushed onto the stack, then r0 is being written a constant value. In such case, we don't have to maintain the r0's value, because it will be overwritten anyway, thus the whole copying thing can be omitted and the data pointer can be simply increased. As a consequence, the new stack's top will be the old r0, and the new r0 will be some zero or random value that will be soon filled in with a data.

[#_pushing_constant_onto_the_stack]
==== Pushing constant onto the stack

This will be slightly simpler than pushing the register, because we don't need to copy the r0 to two places then copy it again to the stack's top.

....
>           ; Go to the target cell.
[-]         ; Zero it.
<           ; Go to the source cell.
[->+<]      ; Until zero, decrease the source cell, go to the target cell, increase it, and go to the source cell.
+++...      ; Increase the source cell as many times as needed to achieve the desired value.
>           ; Set the data pointer to the new r0 (target cell).
....

And again, in some circumstances, the above operations can be optimized:

....
[-]         ; Zero the source cell.
+++...      ; Increase the source cell as many times as needed to achieve the desired value.
>           ; Set the data pointer to the new r0 (target cell).
....

This is possible if r0 is to be written with some value, but the old value won't be used in the meantime.

===
